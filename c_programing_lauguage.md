[toc]
# c语言总结

## gcc 
### gcc 编译过程
* gcc -E 预处理
* gcc -S 编译，输出为汇编代码 /usr/lib/gcc/x86_64-pc-linux-gnu/9.1.0/cc1
* gcc -c　汇编，结果为二进制文件 as
* gcc -o　链接，结果为可执行文件  /usr/lib/gcc/x86_64-pc-linux-gnu/9.1.0/collect2
* -I 查找头文件的路径

### gcc 编译错误

* file not find 头文件包含的错误，正确区分头文件是在当前路径和系统路径中，<>和“”的区别
* 语法错误，中文输入法下输入的字符，空格，引号，逗号等
* undefined reference 链接错误，只有声明，没有定义
* multiple definition of function 对函数多次定义，导致链接错误

### 预处理

* #include 包含头文件
* #define 宏，替换，不进行语法检查，加括号，宏函数
* 条件编译　#ifdef #else #endif
* 预定义宏　\_\_FUNCTION\_\_ 函数名　\_\_LINE\_\_　行号 \_\_FILE\_\_　文件名
* gcc -D 通过命令传入预定义的宏参数，控制程序是debug还是release
* 带#号的，#define ABC(x) #x 字符串化，如ABC(aa) == "aa"
* 两个#号，连接 #define MYDAY(x) myday##x ，MYDAY(1) == myday1

## 语法部分

### 关键字

* 杂项 sizeof 确定内存占用 return 函数返回
* 数据类型，对占用内存大小的确定
    * char 操作内存的最小单位
    * int 
    * short,long
    * unsigned, signed
    * float double
    * void
* 自定义数据类型
    * struct 基本数据类型的集合
    * union 共用内存，可以用于确定系统数据存储的大小端
    * enum 枚举中定义的变量类似与宏定义的常量，有区别的是，宏定义量在预处理阶段被替换，而枚举类型则是在编译阶段进行值的初始化
    * typedef

* 移位符号，对于有符号整数的右移操作，保留符号位，其他位置作以为操作；而对于无符号数，所有位进行移位操作
* 逻辑结构 分支，判断，循环，跳转，switch case default
* 类型修饰符，对内存资源存放位置的限定
    * auto 可读可写，默认情况
    * register，限制变量定义在寄存器中，对访问速度有要求，实际中是否放在寄存器中由编译器决定，取地址符号& 对该类型无效。
    * static 
        * 函数内部的变量，
        * 全局变量，
        * 对函数的修饰，
    * const，只读的变量
    * extern，
    * volatile，告知编译器编译方法的关键字，不优化编译，变量的值可能由外部硬件来改变

-- | 局部变量 | 全局变量 |
-  |        -| -       |
static | 静态存储时期、代码块作用域和空链接 | 静态存储时期、文件作用域和内部链接
no static |动态存储期、代码块的作用域和空链接 |  静态存储期、文件作用域和外部链接

### 运算符

* 算数运算符, + - * / % 求模 % ，取一个范围的数， m % n \in [0, n-1]
* 逻辑运算, ||, &&, >, >=, <, <=, !, ()? () : ()
* 赋值运算, =, +=, -=, &=, 
* 位运算
    * <<, 乘法，*2, 对有符号数，无论正负数都是*2 ;无符号数的作用是仅仅移位。 
    * >>, 有符号数，符号不变, 负数怎么移位都是负数，因此为假(false);无符号数，仅仅是移位
    * &， 屏蔽相应位， &0， &1 取出相应位。清零器
    * |，  | 0 取出相应位，| 1，置位高电平。A | 1 0 0 0 0  第5位高电平，其他不变；A & *  0 1 1 1 1 <==> A & ~(0x1 << 5)第5位低电平，其他不变
    * ^ 异或，交换两个数，a = a ^ b; b = a ^ b; a =a ^ b;
    * ~ 逐位取反，int a =0x0f; ~a = 0xfffffff0;
* 内存访问符号,

